1. 자바스크립트란?
    자바스크립트는 웹 페이지에 생동감을 불어넣기 위해 만들어진 프로그래밍 언어이다


2. <script>태그
    <script>태그를 이용하면 자바스크립트 프로그램을 HTML 문서 대분분의 위치에 삽할 수 있다.

    <script>
        alert('Hello, world!');
    </script>

    <script>태그엔 몇 가지 속이 있는데 요즘엔 잘 사용하지 않는다.

    자바스크립트 코드 양이 많은 경우엔 파일로 소분하여 저장할 수 있는데 이렇게 분해한 각 파일은 src 속성을 이용해 HTML에
    삽입한다.

    <script  src="/path/to/script.js"></script>

    src 속성이 있으면 태그 내부의 코드는 무신된다.


3. 코드 구조 

    1) 문
    문(statement)은 어떤 작업을 수행하는 문법 구조와 명령어를 의마하는데 서로 다른 문은 세미콜론(;)으로 구분한다.

    alert('hello');
    alert('World');

    2) 주석
    한 줄짜리 주석은 두 개의 슬래시 // 로 시작된다.

    // 이 주석은 한 줄을 다 차지합니다.

    여러 줄의 주석은 슬래쉬와 별표 /*로 시작해 별표와 슬래쉬 */로 끝난다.

    /* 여러 줄짜리 주석 예제
    이것은 여러 줄의 주석입니다.
    */

4. 엄격 모드 
    2009년 ECMAScrip5(ES5)가 등장하면서 새로운 기능이 추가되고 기존 기능 일부가 변경되었는데 호환성 문제로 변경사항 대부분은
    ES5의 기본 모드에선 활성하되지 않도록 설계되었다.
    대신 "use strict"라는 특별한 지시자를 사용해 엄격 모드(strict mode)를 활성화 했을 때만 이 변경사항이 활성화되게 했다.

    따라서 ES5의 기능을 사용하기 위하여 스크립트 최상단에 지시자 "use strict" 적어야 한다. 


5. 변수 
    1) 변수
    변수는 데이터를 저장할 때 쓰이는 "이름이 붙은 저장소" 이다.
    자바스크립트에서 let 키워드를 사용하여 변수를 생성한다.

    let message;

    할당 연산자 = 를 사용해 변수 안에 데이터를 저장한다.

    message = 'Hello";

    혹은 let message = 'Hello';

    2) 상수
    변화하지 않는 변수를 선언할 땐 let 대시 const를 사용한다.
    이렇게 const로 선언한 변수를 상수라 부르며 상수는 재할당할 수 없으므로 상수를 변경하려고 하면 에럭가 발생 한다.


6. 자료형
    자바스크립트의 변수는 자료형에 관계없이 모든 데이터일 수 있다. 변수는 어떤 순간에 문자열일 수 있고 다른 순간 숫자가 될 수도 있다.
    이처럼 자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있는 언어를 "동적 타입(dynamically typed)"언어라 한다.

    let message = "Hello";

    message = 123435;

    1) 숫자형
    정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용한다. 정수의 한계는 (2^53 - 1) 과 -(2^53 -1) 사이의 값이다.

    2) BigInt
    위 숫자형의 제약보다 큰 숫자가 필요할 상항에 사용된다. 정수 리터럴 끝에 n을 붙이면 만들 수있다.

    const bigint = 1234567890123456789012345678901234567890n;

    3) 문자형 
    자바스크립트에서는 문자열을 따옴표로 묶는다.

    - 큰따옴표      let str = "Hello";
    - 작은따옴표    let str2 = 'Single quotes are ok too';
    자바스크립트에서는 큰따옴표와 작은따옴표는 기본적인 따옴표로 차이를 두지 않는다.

    - 역 따옴표     let phrase = `can embed another ${str}`;
    역 따옴표를 사용하면 중간에 ${...}를 사용하여 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 있다.

    4) 불린형 
    불린형(논리 타입)은 true 와 false 두 가지 값밖에 없는 자료형이다.

    5) 'null' 값 
    null 값은 지금까지 소개한 자료형 중 어느 자료형에도 속하지 않는 값이다.
    null 값은 오로지 null 값만 포함하는 별도의 자료형이다.

    자바스크립트의 null은 다른 언어의 null 과 성격이 다르다. '존재하지 않는 값', '알 수 없는 값', '비어 있는 값'등을 나타낸다.

    let age = null; 은 age를 알 수 없거나 그 값이 비어있음을 보여준다.

    6) 'undefined' 값 
    undefined 값도  null 값처럼 자신만의 자료형을 형성한다.
    undefined 는 '값이 할당되지 않은 상태'를 나타낼 때 사용한다.

    7) 객체와 심볼 

    객체(object)형은 특수한 자료형이다. 객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표편할 수 있기 때문에 원시(primitive)
    자료형이라 부르는 반면 객체는 테이터 컬렉션이나 복잡한 개체(entity)를 표현할 수 있다.

    심볼(symbol)형은 객체의 고유한 식별자를 만들 때 상용된다.

    8) typeof 연산자
    typeof 연산자는 인수의 자료형을 반환한다. 자료형의 처리 방식을 다르게 하고 싶거나 변수의 자료형을 빠르게 알아내고자 할 떼 유용하다.


7. alert, prompt, confirm을 이용한 상호 작용 
    1) alert
    이 함수가 실행되면 사용자가 확인 버튼을 누를 때까지 메시지를 보여주는 창이 계속 떠있다. 메시지가 있는 작은 창을 모달 창이라고 부른다.

    2) prompt
    result = prompt(title,[default]);
    이 함수가 실행되면 텍스트 메시지와 입력 필드, 확인 및 취소 버튼이 있는 모달 창을 뛰워준다.

    title : 사용자에게 보여줄 문자열 
    default : 입력 필드의 초기값 

    let age = prompt("당신의 나이를 입력해주세요",50);
    alert(`당신의 나이는 ${age}살 입니다.`);    // 당신의 나이는 50살입니다.

    3) confirm 
    result = confirm(question);
    이 함수는 매개변수로 받은 question과 확인 및 취소 버튼이 있는 모달 창을 보여준다
    사용자가 확인 버튼을 누르면 true, 그 외의 경우는 false를 반환한다.

8. 형 변환 
함수와 연산자에 전달되는 값의 대부분은 적절한 자료형으로 자동 변환 되는데 이런 과정을 "형 변환"이라고 한다.
alert가 전달받은 값의 자료형과 관계없이 이를 문자열로 자동 변환하여 보여주는 것이나, 수학 관련 연산자가 전달받은 값을 숫자로 변환하는 경우가
대표적인 형 변화 예시이다.

    1) 문자형으로 변환 
    문자형으로의 형 변환은 문자형의 값이 필요할 때 일어난다.
    alert 메서드는 매개변수로 문자형을 받기 때문에 alert(value)에서 value는 문자형이야 한다. 만약 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변혼된다.

    String(value)함수를 호출해 전달받은 값을 문자열로 변환 할 수도 있다.

    2) 숫자형으로 변환 
    숫자형으로 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.

    alert("6" / "2");       // 3, 문자열이 숫자형으로 자동 변환된 후 연산이 수행됨

    Number(value)함수를 사용하면 주어진 값(value)을 숫자형으로 명시해서 변환할 수 있다.

    3) 불린형으로 변환 
    이 형 변환은 논리 연산을 수행할 때 발생한다.
    Boolean(vlaue)를 호출하면 명시적으로 블리언으로 형 변환이 수행된다.

    숫자 0, 빈 문자열, null, undefined, NaN과 같이 직관적으로 "비어있다"고 느껴지는 값들은 false가 되고 그 외의 값은 true가 된다.


9. 기본 연산자와 수학
    1) 수학 연산자 
    - 덧셈 연산자 : +
    - 뺄셈 연산자 : -
    - 곱셈 연산자 : *
    - 나눗셈 연산자 : /
    - 나머지 연산자 : %
    - 거듭제곱 연산자 : **

    alert(2**4);        // 2*2*2*2 = 16

    2) 이항 연산자 '+'  와 문자열 연결
    덧셈 연산자 + 는 대개 숫자를 더한 결과를 반환한다. 그런데 이항 연사자 + 의 피연산자로 문자열이 전달 되면 덧셈 연산자는 덧셈이 아닌 문자열을 연견한다.

    let s = "my" + " string";
    alert(s) ;  // "mystring"

    이항 연산자 + 를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다는 점을 주의해야 한다.

    alert('1' + 2);     // "12"
    alert(2 + '1');     // "21"

    alert(2 + 2 + '1'); // "41",    연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문 

    이항 덧셈 연산자 + 는 문자열 연결과 변환이라는 특별한 기능을 제공하지만 다른 산술 연산자는 오직 숫자형의 피연산자만 다루고 피연산자가 숫자형이 아닌 경우
    그 형을 숫자형으로 바꾼다

    alert(6 - '2');     // 4,   '2'를 숫자로 바꾼 후 연산 
    alert('6' / '2');   // 3,   두 피연산자를 모두 숫자로 바꾼 후 연산 

    3) 단항 연산자 '+' 와 숫자형으로의 변환 
    숫자에 단항 덧셈 연산자를 붙이면 이 연산자는 아무런 동작을 하지 않지만 피연산자가 숫자가 아닌 경우엔 숫자형으로 변환한다.

    let apples = '2';
    let oranges = '3';

    alert(apples + oranges);    // "23",    문자열을 연결함

    alert(+apples + +oranges);  // 5,   두 피연산자가 숫자형으로 변환되어 연산 

    4) 복합 할당 연산자 

    n = n + 5  => n += 5
    n = n * 2  => n *= 2 처럼 연산자 표현 가능 

    5) 증가. 감소 연산자

    ++
    -- 사용 가능 

    6) 비트 연산자 

    - 비트 AND : &
    - 비트 OR : |
    - 비트 XOR : ^
    - 비트 NOT : ~
    - 왼쪽 시프트 : <<
    - 오른쪽 시프트 : >>
    - 부호 없는 오늘쪽 시프트 : >>>

    7) 쉼표 연산자 

    let a = (1 + 2, 3 + 4);     // 7,   표현식 각각이 모두 평가되지만 마지막 표현식의 평가만 반환됨(3+4)

    alert(a);


10. 비교 연산자 

    - 보다 큼,작음 : a > b, a < b 
    - 보다 크거나 작거나 같음 : a >= b, a <= b 
    - 같음 : a == b 
    - 같지 않음 : a != b 

    1) 불린형 반환
    비교 연산자의 반환 값은 불린형이다.

    2) 문자열 비교 
    alert('Z' > 'A');   // true,    'Z'가 'A' 보다 유니코드가 높음 
    alert('Glow' > 'Glee'); // true,    'G'는 같고 'l'도 같다, 'o'가 'e' 보다 유니코드가 높다.
    alert('Bee' > 'Be');    // true,    문자열의 길이가 다르면 길이가 긴 문자열이 크다 

    3) 다른 형을 가진 값 간의 비교 
    alert('2' > 1);     // true,    문자열 '2'가 숫자 2로 변환된 후 비교 
    alert('01' == 1);   // true,    문자열 '01'이 숫자 1로 변환된 후 비교 

    불린값의 경우 true는 1, false는 0을 변환된 후 비교 

    3) 일치 연산자 
    동등 연산자 == 는 0과 false를 구별하지 못한다. 동등 연산자는 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문이다.

    일치 연산자 === 는 형 변환 없이 값을 비교한다.

    4) null 이나 undefined 와 비교하기
    null 이나 undefined를 다른 값과 비교할 땐 예상치 않은 일들이 발생한다.


11. if 와 ? 를 사용한 처리 

C언어의 if문 과 다르지 않다.

12. 논리 연산자 

||, &&, ! 으로 C 언어와 다르지 않다.

13. nullish 병합 연산자 '??'
nullish 병합 연산자를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 확정되어있는 변수를 찾을 수 있다.

a ?? b => a 가 null 도 아니고 undefined 도 아니면 a, 그 외의 경우엔 b 

let height = 0;

alert(height || 100);   // 100
alert(height ?? 100);   // 0

안전성 관련 이슈 때문에 ??는 && 나 || 와 함께 사용하지 못함(에러 발생)

    
14. while 과 for 반복문 

C 언어의 while, for 문과 다르지 않다.


15. switch 문

C 언의 switch 문과 다르지 않다.

16. 함수
    1) 함수 선언

    function name(para1,para2,....,paraN) {
        // 함수 본문
    }

    함수 선언 및 정의하는 법은 C 언어와 같음 

17. 함수 표현식 
    1) 함수 표현식
    - 함수 선언 
    function sayHi() {
        alert("Hello");
    }

    alert(sayHi);   // ()를 사용하지 않았기에 함수 실행되지 않는다.

    - 함수 표현식
    let sayHi = function() {
        alert("Hello");
    };      // 함수 표현식에서는 끝에 세미 콜론 ; 을 붙인다.

    2) 콜백 함수 
    function ask(question, yes, no) {
        if(confirm(question)) yes();
        else no();
    }

    function showOk() {
        alert("동의하였습니다");
    }

    function showCancel() {
        alert("취소 버튼을 누르셨습니다.");
    }

    ask("동의하십니까?",showOk,showCancel);

    함수 ask의 인수 showOk 와 showCancel 은 콜백 함수 또는 콜백이라고 부른다.

    3) 함수 표현식 vs 함수 선언문
    - 문법의 차이가 있다.     
        . 함수 선언문의 함수는 주요 코드 흐름 중간에 독자적인 구문 형태로 존재한다.
        . 함수 표현식의 함수는 표현식이나 구문 구성 내부에 생성된다.
    - 자바스크립트 엔진이 언제 함수를 생성하는지 
        . 함수 선언문은 함수 선언문이 정의 되기 전에도 호출할 수 있다
        . 함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다.
    - 스코프의 차이 
        . 엄격 모드에서 함수 선언문이 코드 블럭 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수있다.
        하지만 블록 밖에서는 함수에 접근하지 못한다.
        .하지만 함수 표현식을 사용하면 블럭 밖에서도 함수에 접근 할 수 있다.


18. 화살표 함수 기본
함수 표현식보다 단순하고 간결한 문법으로 함수를 만드는 방법은 화살표 함수를 사용하는 것이다.

let func = (arg1,arg2,...,argN) => expression

위 화살표 함수는 아래 함수 표현식의 함수와 같다.

let func = function(arg1,arg2,...,argN){
    return expression;
}

let sum = (a,b) => a + b;

alert(sum(1,2));    // 3

인수가 하나인 경우

let double = n => n * 2;

alert(double(3));   // 6

인수가 없는 경우

let sayHi = () => alert("안녕하세요");

sayHi();

평가해야 할 표현식이나 구문이 여러 개인 함수가 있는 경우

let sum = (a,b) => {
    let result = a + b;
    return result;
}

alert(sum(1,2));    // 3

중괄호안에 평가해야 할 코드를 넣어준다. 그리고 return 지시자를 사용해 결과값을 반환한다.


19. 객체
자바스크립트엔 여덟 가지 자료형이 있는데 이 중 일곱 개는 오직 하나의 데이터(문자열,숫자 등)만 담을 수 있어 '원시형(primitive type)이라 부른다
그런데 객체형은 원시형과 달리 다양한 데이터를 담을 수 있다. 키로 구분된 데이터 집합이나 복잡한 개체(entity)를 저장할 수 있다.

    - 객체 생성 방법
    let user = new Object();        // 객체 생성자 문법
    let user = {};                  // 객체 리터럴 문법

    1) 리터럴과 프로퍼티
    중괄호 {...}안에는 '키:값' 쌍으로 구성된 프로퍼티가 들어간다.

    let user = {        // 객체
        name: "Jone",   // 키: "name", 값: "Jone"
        age: 30         // 키: "age", 값: 30
    };
    '콜론(:)을 기준으로 왼쪽엔 키가, 오른쪽엔 값이 위치한다. 프로퍼티 키는 프로퍼티 '이름' 혹은 '식별자'라고도 부른다.

    프로퍼티는 추가, 삭제할 수 있으며 '점 표기법'을 이용하여 프로퍼티 값을 읽을 수도 있다.

    //프로퍼티 값 얻기
    alert(user.name);   // "Jone"
    alert(user.age);    // 30

    프로퍼티 값엔 모든 자료형이 올 수 있다. 불린형 프로퍼티를 추가하려면 

    user.isAdmin = true;

    이렇게 되면 객체 user 에는 프로퍼티가 name, age, isAdmin 으로 구성되었다.

    delete 연산자를 사용하면 프로터티를 삭제할 수 있다.

    delete user.age;

    user 객체에는 이제 프로퍼티는 name, isAdmin 으로 구성되었다.

    여러 단어를 조합해 프러퍼티 이름을 만든 경우엔 프로퍼티 이름을 따옴표로 묶어줘야 한다.

    let user = {
        name = "Jone",
        age = 30,
        "like birds": true,     // 복수의 단어는 따옴표로 묶어야 한다.  마지막 프러퍼티는 쉼표로 끝날 수 있다.
    };

    2) 대활호 표기법 
    여러 단어를 조합해 프러퍼티 키를 만든 경우렌 점 표기법을 사용해 프로퍼티 값을 읽을 수 없다.

    user.like birds = true;     // 문법 에러가 발생한다.

    자바스크립트는 user.like 까지는 이해하다가 birds를 만나면 문법 에러를 뱉어내는데 유효한 변수 식별자엔 공백이 없어야 하기 때문이다.
    키가 유효한 변수 식별자가 아닌 경우엔 점 표기법 대신 '대괄호 표기법'이라 불리는 방법을 사용해야 한다.
    대괄호 표기법은 어떤 문자열이 있던지 상관없이 동작한다.

    let user={};

    user["like birds"] = true;      // set 

    alret(user["like birds"]);      // true,    get 

    delete user["like birds"];      // delete

    대괄호 표기법 안에서 문자열을 사용할 땐 문자열을 따옴표로 묶어줘야 한다. 따옴표의 종류는 상관 없다.

    let key = "like birds";

    user["like birds"] = true;
    user[key] = true;               // user["like birds"] = true 와 같다.

    let user ={
        nane: "Jone",
        age = 30
    };

    let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요","name");

    // 변수로 접근 
    alert(user[key]);   // "Jone"   (프롬프트 창에 "name"을 입력한 경우)  
                        // 30       (프롬프트 창에 "age"를 입력한 경우)

    그런데 객체 user에 점 표기법의 이런 방식은 불가능하다.
    let key = "name";

    alert(user.key);    // undefined


    3) 계산된 프로퍼티 
    객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우 이를 계산된 프러퍼티라고 부른다.

    let fruit = prompt("어떤 과일을 구매하겠습니까?","apple");

    let bag = {
        [fruit] = 5,    // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 온다.
    };

    alert(bag.apple);   // fruit에 "apple"이 할당되었다면 5가 출력된다.

    위 예시에서 [fruit]는 프로퍼티 이름을 변수 fruit에서 가져오겠다는 것을 의미한다.

    아래 예시는 위 예시와 동일하게 동작한다.

    let fruit = prompt("어떤 과일을 구매하겠습니까?","apple");
    let bag = {};

    // 변수 fruit을 사용해 프러퍼티 이름을 만든다.
    bag[fruit] = 5;

    4) 단축 프로퍼티 

    function makeUser(name, age) {
        return{
            name: name,
            age: age,
            // ...
        };
    }

    let user = makeUser("Jone",30);
    alert(user.name);       // "Jone"

    위 예시의 프로터티들은 이름과 값이 변수의 이름과 동일핟. 이렇게 변수를 사용해 프로퍼티를 만드는 경우는 아주 흔한데,
    프러퍼티 값 단축 구문을 사용하면 코드를 짧게 줄일 수 잇다.

    name: name 대신 name 만 적어주어도 프러퍼티를 설정할 수 있다.

    function makeUser(name, age) {
        return{
            name,       // name: name 와 같음
            age,        // age: age 와 같음 
            // ...
        };
    }

    5) 프로퍼티 이름의 제약 사항 
    변수 이름(키)엔 'for', 'let', 'return' 같은 예약어를 사요하면 안된다.
    하지만 객체 프로퍼티엔 아무런 제약이 없다.

    let obj = {
        for: 1,
        let: 2,
        return: 3
    };

    let obj = {
        0: "test"   // "0": "test"와 동일하다.
    }

    6) 'in' 연산자로 프로퍼티 존재 여부 확인하기 

    let user = {name: "Jone", age: 30};

    alert("age" in user);   // true     user.age가 존재하므로 true
    alert("blabla" in user);    // false    user.blabla가 존재하지 않기에 false 

    in 왼쪽엔 반드시 프로퍼티 이름이 와야 한다.

    7) 'for...in' 반복문
    'for...in' 반복문을 사용하면 객체의 모든 키를 순회할 수 있다. for(;;;) 반복문과 완전히 다르다.

    let user = {
        name: "Jone",
        age: 30,
        isAdmin: true
    };

    for(let key in user) {
        alert(key);     // name, age, isAdmin   키 
        alert(user[key]);   // "Jone", 30 , true    키에 해당하는 값 
    }

    8) 객체 정렬 방식 
    정수 프로퍼티는 자동으로 정렬되고 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬된다.


20. 참조에 의한 객체 복사 
    원시값(문자열,숫자,불린 값)은 값 그대로 저장 할당되고 복사된다.
    객체는 참조에 의해(by referene) 저장되고 복사된다. 즉 변수엔 객체가 저장되는 것이 아니라 객체가 저장되어있는 메모리 주소인 객체에
    대한 참조 값이 저장된다.

    let message = "Hello";
    let phrase = message;

    위 예시에서 두 개의 독립된 변수에 각각 문자열 "Hello"가 저장된다.

    let user ={name: "John"};
    let admin = user;

    위 예시에서는 admin 에는 user의 참조값이 복사된다.

    admin.name = "Pete";
    alert(user.name);       // "Pete"

    즉 위처럼 admin.name를 수정하면 user.name도 같이 변경된다.

    1) 참조에 의한 비교 

    let a = {};
    let b = a;      // 참조에 의한 복사 

    alert(a == b);      // true     두 변수는 같은 객체를 참조한다.
    alert(a === b);     // true

    위 예시는 같은 참조값을 가진 변수이기에 비어있어도 같은 객체를 참조하기에 참이다.

    let a = {};
    let b = {};

    alert(a == b);      // false

    위 예시는 독립된 객체이기에 일치히지 않아 거짓이 반환된다.

    2) 객체 복사, 병합과 Object.assign 
    객체가 할당된 변수를 복사하면 동일함 객체에 대한 참조 값이 복사 된다는것을 알았다.
    그런데 기존에 있던 객체와 똑같으면서 독립적인 객체를 만들려면 어떻게 해야 할까.

    let user = {
        name: "John",
        age: 30
    };

    let clone = {};     // 새로운 빈 객체 

    // 빈 객체에 user 프로퍼티 전부를 복사해 넣는다.
    for(let key in user) {
        clone[key] = user[key];
    }

    // 이제 clone은 완전히 독립적인 복제본이 되었다
    clone.name = "Pete";
    alert(user.name);   // "John"  기존 객체 user에는 여전히 "John"이다.

    Object.assign를 사용하는 방법은 다음과 같다.

    Object.assign(dest,[src1,src2,src3,...])

    객체 src1,...,srcN의 프로퍼티를 dest에 복사하는 작업을 한다.

    let user = {name: "John"};

    let permissions1 = {canView: true};
    let permissions2 = {canEdit: true};

    // permissions1과 permissions2의 프로퍼티를 user로 복사 
    Object,assign(user, permissions1, permissions2);

    // now user = {name:"John", canView: true, canEdit: true}

    위 예시는 assign 메서드를 사용하여 여러 객체를 하나로 병합하는 것이다.

    let user = {name: "John"};

    Object.assign(user, {name: "Pete"});

    alert(user.name);   // user = {name: "Pete"}

    위 예시는 목표 객체(user)에 동일한 이름을 가진 프로퍼티가 있는 경우 기존 값이 덮어씌어 지는 예시이다.

    let user = {
        name: "John",
        age: 30
    };

    let clone = Object.assign({}, user);

    위 예시는 Object.assign을 사용하여 반복문 없이도 간단하게 user에 있는 모든 프로퍼티가 빈 배열에 복사되고 변수에 할당된다.

    3) 중첩 객체 복사 
    객체의 프로퍼티가 객체일 경우 중첩 객체라 하며 이것을 복사하면 참조값이 복사된다. 이 경우는 Object.assign이 아니라 깊은 복사 기능이 있는
    _.cloneDeep(obj)를 사용한다.


21. 메서드와 this 
    객체는 사용자(user), 주문(order) 등과 같이 실제 존재하는 개체(entity)를 표현하고 할 때 생성된다.

    1) 메서드 만들기

    let user = {
        name: "John",
        age: 30
    };

    user.sayHi = function() {
        alert("안녕하세요~");
    };

    user.sayHi();   // "안녕하세요~"

    함수 표현식으로 함수를 만들고 객체 프로퍼티 user,sayHi에 함수를 할당해 주었다.
    이제 객체에 할당된 함수를 호출하면 user 가 인사를 한다. 이렇게 객체 프로퍼티에 할당된 함수를 메서드(method)라 부른다.
    위 예시에서는 user에 할당된 sayHi가 메서드인 것이다.

    2) 메서드 단축 구문

    // 아래 두 객체는 동일하게 동작한다.
    user = {
        sayHi: function() {
            alert("Hello");
        }
    };
    // 단축 구문을 사용함 
    user = {
        sayHi() {       // sayHi: function() 과 동일함 
            alert("Hello");
        }
    };

    위처럼 function을 생략해도 메서드를 정의할 수 있다.

    3) 메서드와 this
    메서드 내부에서 this 키워드를 사용하면 객체에 접근할 수 있다.

    let user = {
        name: "John",
        age: 30,

        sayHi() {
            // 'this' 는 현재 객체를 나타낸다 
            alert(this.name);
        }
    };

    user.sayHi();   // "John"

    user.sayHi()가 실행되는 동안 this는 user를 나타낸다.

    4) 자유로운 this 
    자바스크립트의 this는 다른 프로그래밍 언어의 this와 동작 방식이 다르다. 자바스크립트에선 모든 함수에 this를
    사용할 수 있다.
    this 값은 런타임에 결정된다. 동일한 함수라도 다른 객체에서 호츨했다면 'this'가 참조하는 값이 달라진다.

    let user = {name: "John"};
    let admin = {name: "Admin"};

    function sayHi() {
        alert(this.name);
    }

    // 별개의 객체에서 동일한 함수를 사용함 
    user.f = sayHi;
    admin.f = sayHi;

    // 'this' 는 점(.) 앞의 객체를 참조하기 때문에 this 값이 달라짐 
    user.f();       // "John"  (this==user)
    admin.f();      // "Admin" (this==admin)

    admin['f']();   // "Admin"  점과 대괄호는 동일하게 동작함

    5) this가 없는 화살표 함수 
    화살표 함수는 일반 함수와는 달리 고유한 'this'를 가지지 않는다. 화살표 함수에서 this를 참조하면 
    화살표 함수가 아닌 평범한 외부 함수에서 this 값을 가져온다.


22. new 연산자와 생성자 함수 
    객체 리터럴 {...} 을 사용하면 객체를 쉽게 만들 수 있다. 그런데 개발을 하다 보면 유사한 객체를 여러 개 만들어야 할 때가 
    있는데 복수의 사용자, 메뉴 내 다양한 아이템을 객체로 표현하려고 하는 경우이다.
    'new' 연산자와 생정자 함수를 사용하면 유사한 객체 여러 개를 쉽게 만들 수 있다.

    1) 생성자 함수 
    생성자 함수는 다음과 같은 관례를 따른다
    - 함수 이름의 첫 글자는 대문로 시작한다.
    - 반드시 new 연사자를 붙여 실행한다.

    function User(name) {
        this.name = name;
        this.isAdmin = false;
    }

    let user = new User("보라");

    alert(user.name);       // '보라'
    alert(user.isAdmin);    // false

    new User(...) 를 써서 함수를 실행하면 다음과 같은 알고리즘이 동작한다.
    . 빈 객체를 만드어 this 에 할당한다.
    . 함수 본문을 실행한다. this에 새로운 프로퍼티를 추가해 this를 수정한다.
    . this를 반환한다.

    function User(name) {
        // this = {};   (빈 객체가 임시적으로 만들어짐)

        // 새올운 프로퍼티를 this에 추가함
        this.name = name;
        this.isAdmin = false;

        // return this; (this가 임시적으로 반환됨)
    }

    new User("보라") 이외에도 new User("호진"), new User("지민") 등 을 이용하면 손쉽게 사용자 객체를 만들수 있다


23. 옵셔널 체이닝 '?.'
    옵셔널 체이닝 ?. 을 사용하면 프러퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 잇다.

    1) 옵셔널 체이닝이 필요한 이유 
    let user ={};       // 주소 정보가 없는 사용자.

    alert(user.address.street);     // type err

    문제를 해결하기 위해 && 연산자 사용 

    let user = {};                  // 주소 정보가 없는 사용자 

    alert(user&&user.address&&user.address.street);   // undefined 에러가 발생하지 않는다.     

    2) 옵셔널 체이닝 등장 
    ?. 은 ?. 앞의 평가 대상이 undefined 이거나 null 이면 평가를 멈추고 undefined를 반환한다.

    let user = {};                  // 주소 정보가 없는 사용자 

    alert(user?.address?.street);   // undefined 에러가 발생하지 않는다.     
    
    3) 단락 평가 
    ?. 는 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈춘다. 참고로 이런 평가 방법을 단락 평가라고 부른다.


24. 심볼형
    자바스크립트는 객체 프로퍼티 키로 오직 문장형과 심볼형만을 허용한다.

    1) 심볼
    - 심볼(symbol)은 유일한 식별자를 만들고 싶을 때 사용한다.
      Symbol() 을 사용하면 심볼값을 만들 수 있다.

      // id는 새로운 심볼이 된다.
      // 심볼 id에는 "id"라는 설명이 붙는다.
      let id = Symbol("id");  

    심볼을 만들 때 심볼 이름이라 불리는 설명을 붙일 수도 있다.
    심볼은 유일성이 보장되는 자료형이기 때문에 설명이 동일한 심볼을 여러 개 만들어도 각 심볼값은 다르다.

    2) '숨김' 프로퍼티 
    심볼을 이용하면 '숨김' 프로퍼티를 만들 수 있다. 숨김 프로퍼티는 외부 코드에서 접근이 불가능하고 값도 덮어쓸 수 없는 프로퍼티이다.

    let user = {
        name: "John"
    };

    let id = Symbol("id");

    user[id] = 1;

    alert(user[id]);    // 1

    3) Symbol in a literal
    객체 리터럴 {...}을 사용해 객체를 만든 경우, 대괄호를 사용해 심볼형 키를 만들어야 한다.

    let id = Symbol("id");

    let user = {
        name: "John",
        [id]: 123       // "id": 123은 안됨
    };

    "id": 123 이라고 하면 심볼 id가 아니라 문자열 "id" 가 키가 된다.

    4) 심볼은 for...in 에서 배제된다.
    키가 심볼인 프로퍼티는 for...in 반복문에서 배제된다.
    하지만 Object.assign 은 키가 심볼인 프로퍼티를 배제하지 않고 객체 내 모든 프로퍼티를 복사한다.

    5) 전역 심볼
    전역 심블 레지스트리는 이름이 같은 심블이 같은 개체를 가르키길 원할 때 사용하며 전역 심블 레지스트리 안에 심블을
    만들고 해당 심블에 접근하면 이름이 같은 경우  항상 동일한 심블을 반환한다.

    레지스트리 안에 심볼을 읽거나 새로운 심볼을 생성하려면  Symbol.for(key)를 사용한다.
    전역 심볼 레지스트리를 뒤져서 해당 심볼의 이름을 얻어내려면 Symbol.keyFor(sym)를 사용한다.

    // 이름을 이용행 심볼을 찾음 
    let sym = Symbol.fot("name");
    let sym2 = Symbol.for("id");

    // 심볼을 이용해 이름을 얻음
    alert(Symbol.keyFor(sym));      // "name"
    alert(Symbol.keyFor(sym2));     // "id"


25. 객체를 원시형으로 변환하기 
    객체끼리 더하거나 객체끼리 뻬는 연산을 하는 경우 혹은 alert(obj)로 객체를 출력할 경우등 모든 경우에 자종 형 변환이 일어난다.
    객체는 원시값으로 변환되고 그 후에 연산이 수행된다.


26. 원시값의 메서드 
    자바스크립트는 원시값(문자열,숫자 등)을 마치 객체처럼 다룰 수 있게 해주는데 원시값은 객체는 아니다.

    - 원시값 
        . 원시형 값이다.
        . 원시형의 종류는 문자(string), 숫자(Number), bigint, 불린(Boolean), 심볼(symbol), null, undefined 형으로 일곱 가지이다.

    - 객체
        . 프로퍼티에 다양한 종류의 값을 저장할 수 있다.
        . {name: "John", age: 30} 과 같이 중괄호{}를 사용해 만들 수 있다.
        . 자바스크립트에는 여러 종류의 객체가 있는데 함수도 객체의 일종이다.
        . 객체의 장점중 하나는 함수를 프로퍼티로 저장할 수 있다는 것이다.


    'null' 과 'undefined'를 제외한 원시값에 다양한 메서드를 호출할 수 있다 
    원시값에 메서드를 호출하려 하면 임시 객체가 만들어진다.


27. 숫자형
    1) 숫자를 입력하는 방법
    - let billion = 1000000000;
    - let billion = 1e9;
    - let a = 0xFF;     // 16진수
    - let b = 0o377;    // 8진수
    - let c = 0b11111111;   // 2진수

    2) toString(base)
    num.toString(base) 메서드는 base 진법으로  num 를 표현한 후 이를 문자형으로 변환해 반환한다.
    base는 2, 8, 10, 16, 36 등으로 사용하며 10이 기본값이다.

    let num = 255;

    alert(num.toString(16));    // FF
    alert(num,toString(2));     // 11111111

    숫자를 대사으로 메서드 toString을 호출하면 숫자 다음에 점 두 개 ..을 붙여야 한다.

    alert(123456..toString(36));    // 2n9c
    혹은
    alert((123456).toString(36));

    3) 어림수 구하기 
    어림수를 구하는 것은 숫자를 다룰때 가장 많이 사용되는 연산 중 하나이다.

    - Math.floor : 소수점 첫째 자리에서 버림 3.1 => 3 , -1.1 => -2
    - Math.ceil : 소수점 첫째 자리에서 올림  3.1 => 4 , -1.1 => -1
    - Math.round : 소수점 첫째 자리에서 반올림 3.1 => 3 , 3.6 => 4
    - Math.trunc : 소수부를 무시

    let num = 12.34;
    alert(num.toFixed(1));      // "12.3"

    let num = 12.36;
    alert(num.toFixed(1));      // "12.4"

    alert(num.toFixed(5));      // "12.36000"

    toFixed(n)은 소수점 n 번째 수까지 어림수를 구한 후 이를 문자형으로 반환해주는 메서드이다.

    숫자는 내부적으로 64비트 형식으로 표현되며 숫자가 너무 커지면 64비트 공간이 넘쳐 Infinity 로 처리된다.
    (52비트 숫자, 11비트 소수점위치, 1비트 부호)

    4) isNaN 과 isFinite

    - isNaN(value) : 인수를 숫자로 변환한 다음 NaN인지를 테스트함. NaN 이면 true 반환 
    - isFinite(vlaue) : 인수를 숫자로 변환하고 변환한 숫자가 NaN / Infinity / -Infinity 가 아닌 일반 숫자인 경우 true 반환 

    5) parselnt 와 parseFloat
    두 함수는 불가능할 때까지 문자열에서 숫자를 읽고 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반혼한다.
    parselnt는 정수, parseFloat는 부동 소수점 숫자를 반환 한다.

    6) 기타 수학 함수 

    - Math.random() : 0 과 1 사이의 난수를 반환한다.
    - Math.max(a,b,c....) / Math.min(a,b,c....) : 인수 중 최대/최소값을 반환한다.
    - Math.pow(n,power) : n 을 power 만큼 거듭제곱한 값을 반환한다.


28. 문자열 
    자바스크립트엔 글자 하나만 저장할 수 있는 별도의 자료형은 없다. 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장된다.
    자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상 UTF-16 형식을 따릅니다.

    1) 따옴표
    - '작은따옴표'
    - "큰따옴표"
    - `백틱`

    큰따옴표나 작은따옴표는 기능상 차이가 없다. 그런데 백택엔 특별한 기능이 있다. 표현식을 ${...}로 감싸고 이를 백틱으로 감싼 문자열 
    중간에 넣어주면 해당 표션식을 문자열 중간에 쉽게 삽입할 수 있다.

    백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수 있다

    let guestList = `손님:
      * John
      * Pete 
      * Mary 
      `;

     alert(guestList);  // 손님 리스트를 여러 줄에 걸쳐 출력함  

    2) 특수 기호
    '줄 바꿈 문자'라 불리우는 특수 기호 '\n'을 사용하면 작은따옴표나 큰따옴표도 여려 줄 문자열을 만들 수 있다.

    let guestList = "손님:\n * John\n * Pete\n *Mary";

    alert(guestList);   // 위 백틱을 이용한 손님 리스트와 같은 출력을 한다.

    특수 문자 목록
    - \n            줄바꿈
    - \r            캐리지 리턴 
    - \' , \"       따옴표 
    - \\            역슬래시
    - \t            탭 
    - \b, \f, \v    백스페에스, 폼 피드, 세로 탭 
    - \xXX          16진수 유니코드     'z'는 '\x7A' 와 동일함 
    - \uXXXX        UTF-16 인코딩 규칙을 사용한 16진수 코드 
    - \u{XX...XX}   UTF-32로 표현한 유니코드 기호 

    alert('I\'m the Walrus');       // I'm the Walrus 

    alert(`I'm the Walrus`);        // 위 예시와 같은 출력  
    
    백텍은 특수 문자 \' 를 사용하지 않아도 ' 표시된다.

    3) 문자열 길이 
    length 프로퍼티엔 문자열의 길이가 저장된다.

    alert(`My\n`.length);   // 3   \n은 특수문자 하나로 취급되기에 3이다.

    length는 함수가 아니고 프로퍼티이기에 뒤에 괄호를 붙일 필요가 없다.

    4) 특정 글자에 접근하기 
    문자열내 특정 위치인 pos에 있는 글자에 접근 하려면 [pos]같이 대괄호를 이용하거나 str.charAt(pos)라는 에서드를 
    호출하면 된다. 위치는 0 부터 시작한다.

    let str = "Hello";

    // 첫 번째 글자 
    alert(str[0]);  // H
    alert(str.charAt(0));   // H 

    // 마지막 글자
    alert(str[str.length - 1]); // o 

    근래에는 대괄호를 이용하는 방식을 사용한다. charAt 는 하위 호환성을 위해 남아있는 메서드라 생각된다.
    두 접근 방식의 차이는 반환할 글자가 없을 때 드러난다. 접근하려는 위치에 글자가 없는 경우 []는 undefined를,
    charAt는 빈 문자열을 반환한다.

    for..of 을 이용하면 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있다.

    for(let char of "Hello") {
        alert(char);    // H, e, l, l, o 
    }

    5) 문자열의 불변성 
    문자열은 수정할 수 없다.

    let str = "Hi";

    str[0] = 'h';   //error
    alert(str[0]);  // 동작하지 않는다.

    이런 문제를 피하려면 완전히 새로운 문자열 하나 만든 다음 이 문자열을 str에 할당하면 된다.

    let str = "Hi";

    str = 'h' + str[1];

    alert(str);     // hi 

    6) 대, 소문자 변경하기
    메서드 toLowerCase() 와 toUpperCase()는 대문자를 소문자로 , 소문자를 대문자로 변경 시켜준다.

    7) 부분 문자열 찾기 
    - str.indexOf(substr,pos) 메서드를 이용하기
    이 메서드는 문자열 str 의 pos 에서 부터 시작해, 부분 문자열 substr 이 어디에 위치하는지를 찾아준다.
    원하는 부분 문자열을 찾으면 위치를 반환하고 그렇지 않으면 -1 을 반환한다.

    let str = 'Widget with id';

    alert(str.indexOf('Widget'));   // 0,   str은 'Widget' 으로 시작함 
    alert(str.indexOf('widget'));   // -1,  indexOf는 대소문자를 구분하기에 원하는 문자열이 없음 

    alert(str.indexOf("id"));   // 1,   "id"는 첫 번째 위치에서 발견됨(Widget에서 id)

    - str.lastIndexOf(substr,pos) 
    indexOf 와 유사하지만 문자열 끝에서 부터 부분 문자열을 찾는다.

    - 비트 NOT 연산자를 사용한 기법 
    비트 NOT 연자자 ~를 사용하면 n 이 32 비트 정수일 때 ~n은 -(n+1)이 된다.
    n 중 ~n 을 0 으로 만드는 경우는 n === -1 일 때가 유일하다.
    이를 응용해서 indexOf가 -1을 반환하지 않는 경우를 if(~str.indexOf("..."))로 검사한다.

    - includes, starstWith, endsWith 
    str.includes(substr, pos) 는 str에 부분 문자열  substr이 있는지에 따라 true나 false를 반환한다.
    str.startsWith 와 str.endsWith는 메서드 이름 그대로 문자열 str이 특정 문자열로 시작하는지 여부와
    특정 문자열로 끝나는지 여부를 확인할 때 사용한다.

    8) 부준 문자열 추출하기 
    - str.slice(start [, end]) : 문자열의 start 부터 end 까지(end는 미포함)를 반환한다.

    let str = "stringify";

    alert(str.slice(0,5));  // 'strin', 0 번째부터 5번째 위치까지 (5번째 위치의 글자는 포함하지 않는다.)
    alert(str.slice(0,1));  // 's'

    alert(str.slice(2));    // 'ringify',   2번째 부터 끝까지 

    alert(str.slice(-4,-1));    // 'gif',   끝에서 4번째부터 시작해 끝에서 1번째 위치까지 

    - str.substring(start [, end]) : start 와 end 사이에 있는 문자열을 반환한다. substring 는 slice 와 아주
    유사하지만 start 가 end보다 커도 괜찮다는 차이가 있다.

    let str = "stringify";

    // 동일한 부분 문자열 반환 
    alert(str.substring(2,6));  // 'ring'
    alert(str.substring(6,2));  // 'ring'

    // slice를 사용하면 결과가 다름
    alert(str.slice(2,6));  // 'ring'
    alert(str.slice(6,2));  // ' ', 빈 문자열 

    substring은 음수 인수를 허용하지 않는다. 음수는 0으로 처리한다.

    - str.substr(start [, length]) : start 에서 시작해 length 개의 글자를 반환한다.
    substr 은 끝 위치 대신 길이를 기준으로 문자열을 추출한다는 점에서 substring 과 slice 와 차이가 있다.

     let str = "stringify";

     alert(str.substr(2,4));    // 'ring' 두번째 부터 글자 네 개 
     alert(str.substr(-4,2));   // 'gi'  끝에서 네번째 위치부터 글자 두 개

     9) 문자열 비교하기 
     자바스크립트에서 모든 문자열은 UTF-16을 사용해 인코딩되기에 모든 글자가 숫자 형식의 코드와 매칭된다.
     따라서 알파벳 소문자는 대문자보다 항상 큰 결과가 나온다.
     이에 코드로 글자를 얻거나 글자에서 연관 코드를 알아내는 메서드를 알아보자.

     - str.codePointAt(pos) : pos 에 위치한 글자의 코드를 반환한다.

     alert("z".codePointAt(0)); // 122
     alert("Z".codePointAt(0)); // 90

    - String.fromCodePoint(code) : 숫자 형식의 code 에 대응하는 글자를 만들어 준다.

    alert(String.fromCodePoint(90));    // 'Z'

    // \u 뒤에 특정 글자에 대응하는 16진 코드를 붙이는 방식으로도 원하는 글자를 만들 수 있다.
    // 90을 16진수로 변환하면 5a
    alert('\u005a');    // 'Z'

    10) 문자열 제대로 비교하기
    str.localsCompare(str2) : ECMA-402에 정의한 규칙에 따라 str이 str2보다 작은지, 같은지, 큰지를 내타내주는 정수가 반환된다
    . str이 str2 보다 작으면 음수 반환 
    . str이 str2 보다 크면 양수를 반환
    . str과 str2가 같은면 0이 반환 


29. 배열
    키를 사용해 식별할 수 있는 값을 담은 컬렉션은 객체라는 자료구조를 이용해 저장하는데. 첫 번째 요소, 두 번째 요소, 세 번째 요소 등 순서가 
    있는 컬렉션이 필요할 때가 생긴다. 이런 순서가 있는 컬렉션을 저장할 때 쓰는 자료구조는 배열을 사용한다.

    1) 배열 선언

    let arr = new Array();
    let arr = [];

    대분분 두 번째 방법으로 배열은 선언하는데 대괄호 안에 초기 요소를 넣어주는 것이 가능하기 때문이다.

    let fruits = ["사과", "오랜지", "자두"];

    alert(fruit[0]);    // 사과 
    alert(fruit[1]);    // 오랜지
    alert(fruit[2]);    // 자두

    같은 방법으로 요소를 수정할 수 있다.

    fruit[2] = "배";    // 배열이 ["사과", "오랜지", "배"]로 바뀜 

    새로운 요소를 배열에 추가하는 것도 가능하다.

    fruit[3] = "레몬";  // 배열이 ["사과", "오랜지", "배", "레몬"]으로 바뀜 

    length를 사용하면 배열에 담긴 요소가 몇 개인지 알아낼 수 있다.

    alert(fruit.length);    // 4

    alert를 사용해 요조 전체를 출력하는 것도 가능하다 

    alert(fruit);   // 사과, 오랜지, 배, 레몬 

    배열 요소의 자료형엔 제약이 없다.

    let arr = ["사과", {name:"이보라"}, true, function() {alert("안녕하세요.");}];

    // 인덱스 1인 요소(객체) 의 nane 프로퍼티를 출력
    alert(arr[1].name); // 이보라 

    // 인덱스가 3인 요소(함수)를 실행
    arr[3]();       // 안녕하세요.

    - pop : 배열 끝 요소를 제거하고 제거한 요소를 반환한다.

    let fruit = ["사과", "오랜지", "배"];

    alert(fruit.pop());     // 배열에서 '배'를 제거하고 제거된 요소를 얼럿창에 뛰움
    alert(fruit);           // 사과, 오랜지 

    - push : 배열 끝 요소를 추가한다.

    let fruit = ["사과", "오랜지"];

    fruit.push("배");

    alert(fruit);           // 사과, 오랜지, 배

    fruit.push(...)를 호출하는 것은 fruit[fruit.length] = ... 하는 것과 같은 효과이다.

    - shift : 배열 앞 요소를 제거하고 요소를 반환한다.

    let fruit = ["사과", "오랜지", "배"];

    alert(fruit.shift());   // 배열에서 '사과'를 제거하고 제거된 요소를 얼럿창에 뛰움
    alert(fruit);           // 오랜지, 배

    - unshift : 배열 앞에 요소를 추가한다.

    let fruit = ["오랜지", "배"];

    fruit.unshift("사과");

    alert(fruit);           // 사과, 오랜지, 배

    push 와 unshift는 요소 여러 개를 한 번에 더해줄 수 있다.

    let fruit =["사과"];

    fruit.push("오랜지", "배");
    fruit.unshift("파인에플", "레몬");

    alert(fruit);           // 파인에플, 레몬, 사과, 오랜지, 배

    2) 배열의 내부 동작 원리 
    배열은 특별한 종류의 객체이다. 다만 배열은 키가 숫자라는 점만 다르다.
    따라서 배열은 객체처럼 동작한다.

    3) 성능
    push 와 pop은 빠르지만 shift 와 unshift 는 느리다.

    4) 반복문
    for 문과 for..of 문으로 순회 할 수 있다.

    let arr = ["사과", "오랜지", "배"];

    for(let i = 0; i < arr.length; i++) {
        alert(arr[i]);
    }

    for(let i of arr) {
        alert(i);
    }

    다만 for.. in 은 배열에서 사용하기엔 부적절하다.

    5) 'length' 프로퍼티 
    arr.length = 0 을 사용하면 간단하게 배열을 비울 수 있다.

    6) new Array()

    7) 다차원 배열

    8) toString 
    배열엔 toString 메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환된다.


30. 배열과 메서드 
    1) 요소 추가, 제거 메서드
    - arr.push(...items) : 맨 끝에 요소 추가 
    - arr.pop() : 맨 끝 요소 제거 
    - arr.shift() : 맨 앞 요소 제거 
    - arr.unshift(...items) : 맨 앞에 요소 추가 

    - arr.splice(index[, deleteCount, elem1, ... , elemN]) 
    배열에서 요소를 하나만 지우고 싶을 경우 배열 역시 객체형이므로 프로퍼티를 지울 때 쓰는 delete 를 사용하면
    원하는 요소는 지워지지만 배열 요소는의 갯수는 변하지 않는다. 지웠지만 빈 공간으로 남기 때문이다.

    let arr = ["I", "go", "Home"];

    delete arr[1];      // "go"를 삭제함 
    alert(arr[1]);      // undefined

    alert(arr.length);  // 3, arr = ["I",  , "Home"]

    하지만 splice를 사용하면 위 문제는 해결된다. 요소를 제거하면 갯수도 줄어든다.

    let arr = ["I", "study", "JavaScript"];

    arr.splice(1, 1);   // 인덱스 1부터 요소 1개 제거 

    alert(arr);     // ["I", "JavaScript"]

    요소를 지우고 다른 요소로 교체할 수도 있다.

    let arr =["I", "study", "JavaScript", "right", "now"];

    // 처음 부터 세 개의 요소를 지우고 이자리를 다른 요소로 대체한다.
    arr.splice(0, 3, "Let's", "dance");

    alert(arr); // ["Let's", "dance", "roght", "now"]

    splice 는 삭제된 요소로 구성된 배열을 반환한다.

    let arr =["I", "study", "JavaScript", "right", "now"];

    // 처음 두 개 요소를 삭제함
    let removed = arr.splice(0, 2);

    alert(removed);     // ["I", "study"]   삭제된 요소로 구성된 배열 

    splice 메서드의 deleteCount를 0 으로 설정하면 요소를 제거하지 않으면서 새오룬 요소를 추가할 수 있다.

    let arr = ["I", "study", "JavaScript"];

    arr.splice(2, 0, "complex", "language");   // 인덱스 2부터 요소를 0개 제거하고 요소를 추가한다.

    alert(arr);     // ["I", "study", "complex", "language", "JavaScript"]

    - arr.slice([start], [end]) 
    이 메서는 'start' 인텍스부터 'end' 인덱스까지의 요소를 복사한 새로운 배열를 반환하는데 'end' 인댁스의 값은 제외된다.
    'start' 와 'end' 는 둘 다 음수일 수 있는데 이땐 배열 끝에서 부터 요소의 개수를 의미한다.

    let arr = ["t", "e", "s", "t"] ;

    alert(arr.slice(1, 3));     // 'e', 's'  인덱스 1인 요소부터 3인 요소 까지 복사(인덱스 3인 요소는 제외)

    alert(arr.slice(-2));       // "s", "t"  인덱스가 끝에서 2번째인 요소 부터 끝까지 복사 

    - arr.concat(arg1, arg2,...)
    기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가하고 할 때 사용한다.
    인수엔 배열이나 값이 올 수 있는데 인수의 개수엔 제한이 없다.
    메서드를 호출하면 arr에 속한 모든 요소와 arg1, arg2 드에 속한 모든 요소를 한데 모은 새로운 배열이 반환된다.

    let arr = [1, 2];

    // arr 의 요소 모두와 [3,4]의 요소 모두를 한데 모든 새로운 배열이 만들어진다.
    alert(arr.concat([3, 4]));  // 1,2,3,4

    // arr 의 요소 모두와 [3, 4] 의 요소 모두, [5, 6] 의 요소 모두를 모은 새로운 배열이 만들어진다.
    alert(arr.concat([3, 4],[5, 6]));   // 1,2,3,4,5,6

    // arr 의 요소 모두와 [3, 4] 의 요소 모두, 5와 6을 한데 모은 새로운 배열이 만들어진다.
    alert(arr.concat([3, 4], 5, 6));    // 1,2,3,4,5,6

    concat 메서드는 제공받은 배열의 요소를 복사해 활용하는데 객체가 인자로 넘어오면 객체는 분해되지 않고 통으로 복사되어 
    더해진다.

    let arr = [1, 2];

    let arrLink = {
        0: "something",
        length: 1
    };

    alert(arr.concat(arrLink));     // 1,2,[object Object]

    그런데 인자로 받은 유사 배열 객체에 특수한 프로퍼티 Symbol.isConcatSpreadable 이 있으면 concat은 이 개체를 배열처럼 
    취급한다. 따라서 객체 전체가 아닌 객체 프로퍼티의 값이 더해진다.

    let arr = [1, 2];

    let arrLink = {
        0: "something",
        1: "else",
        [Symbol.isConcatSpreadable]: true,
        length: 2
    };

    alert(arr.concat(arrLink));     // 1,2,something,else

    2) forEach로 반복작업 하기 
    arr.forEach 는 주어신 함수를 배열 요소 각각에 대해 실행할 수 있게 해준다

    arr.forEach(function(item, index, array) {
        // 요소에 무언가를 할 수 있다.
    });

    요소 모두를 얼럿창을 통해 출력해 주는 코드이다 
    // for each element call alert
    ["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

    3) 배열 탐색하기 
    - arr.indexOf(item, from) : 인덱스 from 부터 시작해 item(요소)을 찾는다. 요소를 발견하면 해당 요소의 인덱스를
    반환하고 발견하지 못하면  -1을 반환한다.

    - arr.lastindexOf(item, from) : arr.indexOf 메서드와 동일한 기능을 하는데 검색을 끝에서 부터 시작한다는 점만 다르다.

    - arr.includes(item, from) : 인덱스 from 부터 시작해 item 이 있는지를 검색하는데 해당 요소를 발견하면 true를 반환한다.

    let arr = [1, 0, false];

    alert(arr.indexOf(0));  // 1
    alert(arr.indexOf(false));  // 2
    alert(arr.indexOf(null));   // -1

    alert(arr.includes(1));  // true 

    위 메서드를은 요소를 찾을 때 완전 항등 연산자 === 을 사용한다는 점을 유의해야한다. false를 검색하면 정확히 false만을 검색하지 
    0 을 검색하진 않는다.

    const arr = [NaN];
    alert(arr.indexOf(NaN));    // -1 (완전 항등 비교 === 는 NaN엔 동작하지 않으므로 0 이 출력되지 않는다.)
    alert(arr.includes(NaN));   // true     (NaN의 여부를 확인함)

    - arr.find(function(item, index, array)) : true가 반환되면 반복이 멈추고 해당 요소를 반환하고 없으면 undefined를 반환함
        . item : 함수를 호출할 요소
        . index : 요소 인덱스 
        . array : 배열 자기 자신 

    - arr.findIndex(function(item, index, array) : find와 동일한 일을 하나 조건에 맞는 요소를 반환하는 대신 해당 인덱스를 반환한다.   

    - arr.filter(function(item, index, array) : 조건에 충족하는 요소를 순차적으로 담은 배열을 반환하고 없으면 빈 배열을 반환한다.

    4) 배열을 변형하는 메서드
    - arr.map(function(item, index, array)) : 배열 요소 전체를 대상으로 함수를 호출하고 함수 호출 결과를 배열로 반환한다.

    let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => ltem.length);
    alert(lengths);     // 5,7,6

    - arr.sort(fn) : 배열의 요소를 정렬해 준다. 배열 자체가 변경된다.
    메서드를 호출하면 재정렬 된 배열이 반환되는데 이미 arr 자체가 수정되었기 때문에 반환 값은 잘 사용되지 않는다.

    let arr = [1, 2, 15];

    // arr 내부가 재 정렬된다.
    arr.sort();

    alert(arr);     // 1, 15, 2

    기대했던 결과(1, 2, 15)가 아니라 (1, 15, 2) 되었는데 이는 요소를 문자열로 취급하여 재 정렬되었기 때문이다.
    이러한 경우 기존 정렬 기준 대신 새로운 정렬 기준을 만들어 주어야 하며 이를 위해 arr.sort() 에 새로운 기준을 실행하는 함수를 넘겨줘야 한다.

    function compareNumeric(a, b) {
        if(a > b) return 1;
        if(a == b) return 0;
        if(a < b) return -1;
    }

    let arr = [1, 2, 15];

    arr.sort(compareNumeric);

    alert(arr);     // 1,2,15

    - arr.reverse() : arr의 요소를 역순으로 정렬시켜주는 메서드이다.

    let arr = [1, 2, 3, 4, 5];
    arr.reverse();

    alert(arr); // 5,4,3,2,1

    - str.split(delim) : 구분자(delimiter) delim 을 기준으로 문자열을 쪼개준다.

    let names = 'Bilbo, Gandalf, Nazgul';

    let arr = names.split(', ');

    for(let name of arr) {
        alert(`${name}에게 보내는 메시지`);     // Bilbo에게 보내는 메세지  
    }

    split 메서드는 두 번째 인수로 숫자를 받을 수 있는데 이 숫자는 배열의 길이를 제한한다.

    let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);
    alert(arr);     // Bilbo, Gandalf

    split(s)의 s를 빈 문자열로 지정하면 문자열을 글자 단위로 분리할 수 있다.

    - arr.join(glue) : split 과 반대 역활을 하는 메서드이다. glue를 접착제처럼 사용해 배열 요소를 모두 합친 후 
    하나의 문자열로 만들어준다.

    let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

    let str = arr.join(';'); // 배열 요소 모두를 ;를 사용해 하나의 문자열로 합칩니다.

    alert( str ); // Bilbo;Gandalf;Nazgul

    - arr.reduce(function(accumulator, item, index, array) { // ...}, [initial]);
    . accumulator : 이전 함수 호출 결과, initial 은 함수 최소 호출 시 사용되는 초기값(옵선)
    . item : 현재 배열 요소 
    . index : 요소의 위치 
    . array : 배열 

    forEach, for, for..of 를 사용하면 배열 내 요소를 대상으로 반복 작업을 할 수 있다. 각 요소를 돌면서 반복 작업을 수행하고,
    작업 결과물을 새로운 배열 형태로 얻으려면 map을 사용한다.
    arr.reduce 와 arr.reduceRight 도 이런 메서드들과 유사한 작업을 해준다. 
    배열을 기반으로 값 하나를 도출할 때 사용된다.

    첫 번째 인수는 앞서 호출했던 함수들의 결과가 누적 저장되는 '누산기(accumulator)'라고 생각하면 된다. 마지막 함수까지 호출되면 
    이 값이 reduce의 반환 값이 된다.

    arr.reduceRight 는 reduce 와 동일한 기능을 하지만 배열의 오른쪽부터 연산을 수행한다는 점이 다른 메서드이다.

    5) Array.isArray 로 배열 여부 알아내기 
    자바스크립트에서 배열은 독립된 자료형이 아니고 객체형에 속한다. 따라서 typeof로는 일반 객체와 배열을 구분할 수 없다.

    - Array.isArray(value) : value 가 배열이면 true, 아니면 false를 반환한다.

    alert(Array.isArray({}));   // false 
    alert(Array.isArray([]));   // true 

    6) 배열 메서드와 'thisArg' 
    함수를 호출하는 대분의 배열 메서드(find, filter, map등 sort는 제외)는 thisArg라는 매개변수를 옵션으로 받을 수 있다.

    arr.find(func, thisArg)
    arr.filter(func, thisArg)
    arr.map(func, thisArg)

    thisArg는 func 의 this가 된다.


31. iterable 객체 
    반복 가능한(iterable, 이터러블) 객체는 배열을 일반화한 객체이다. 이터러블 이라는 개념을 사용하면 어떤 객체이든 for..of 반복문을 적용할 수 있다.
    배열은 대표적인 이터러블이다. 문자열 역시 이터러블의 예이다.

    1) Symbol.iterator
    - obj[Symbol.iterator]의 결과는 이터레이터라고 부른다. 이터레이터는 이어지는 반복 과정을 처리한다.
    - 이터레이터엔 객체 {dine:Boolean, value:any} 을 반환하는 메서드 next() 가 반드시 구현되어 있어야 한다. 여기서 done:true 은 반복이 끝났음을
    의미하고 그렇지 않은 경우엔 vlaue가 다음 값이 된다.

    2) 문자열은 이터러블이다.

    3) 이터레이터를 명시적으로 호출하기

    4) 이터러블과 유사 배열
    - 이터러블은 메서드 Symbol.iterator 가 구현되 객체이다.
    - 유사 배열은 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체이다.

    5) Array.from 
    범용 메서드 Array.from 은 객체를 받아 이터러블이나 유사 배열인지 조사한다. 넘겨 받은 인수가 이터러블이나 유사 배열인 경우,
    새로운 배열을 만들고 객체의 모든 요소를 새롭게 만든 배열로 복사한다.


32. 맵 과 셋
    - 객체 : 키가 있는 컬렉션을 저장함
    - 배열 : 순서가 있는 컬렉션을 저장함 

    1) 맵 
    맵(map)은 키가 있는 데이터를 저장한다는 점에서 객체와 유사하지만 키에 다양한 자료형을 허용한다는 점에서 차이가 있다.

    - new Map() : 맵을 만든다.
    - map.set(key, value) : key를 이용해 value를 저장한다.
    - map.get(key) : key에 해당하는 값을 반환한다. key가 존재하지 않으면 undefined를 반환한다.
    - map.has(key) : key가 존재하면 true, 존재하지 않으면 false를 반환한다.
    - map.delete(key) : key에 해당하는 값을 삭제한다.
    - map.clear() : 맵 안의 모든 요소를 제거한다.
    - map.size : 요소의 개수를 반환한다.

    let map = new Map();

    map.set('1', 'str1');       // 문자형 키 
    map.set(1, 'num1');         // 숫자형 키 
    map.set(true, 'bool1')      // 블린형 키

    // 객체는 키를 문자형으로 변환한다 
    // 맵은 키의 타입을 변환시키지 않고 그래도 유지한다.
    alert(map.get(1));      // 'num1'
    alert(map.get('1'));    // 'str1'
    alert(map.size);        // 3

    맵은 객체와 달리 키를 문자형으로 변환하지 않는으며 자료형의 제약이 없다.

    맵은 키로 객체를 허용한다. 이는 맵의 가장 중요한 기능 중 하나이다. 객체에는 문자열 키를 사용할 수 있다. 하지만 객체 키는 
    사용할 수 없다.

    2) 맵의 요소에 반복 작업하기 
    다음 세 가지 메서드를 사용해 맵의 각 요소에 반복 작업을 할 수 있다.
    - map.keys() : 각 요소의 키를 모은 반복 가능한(iterable, 이터러블) 객체를 반환한다.
    - map.vlaues() : 각 요소의 값을 모은 어터러블 객체를 반환한다.
    - map.entries() : 요소의 [키, 값]을 한 쌍으로 하는 이터러블 객체를 반환한다. 이 이터러블 객체는 for..of 반복문의 기초로 쓰인다.

    let recipeMap = new Map([
        ['cuccumber', 500],
        ['tomatoes', 350],
        ['onion', 50]
    ]);

    // 키(vegetable)를 대상으로 순회한다.
    for(let vegetable of recipeMap.keys()) {
        alert(vegetable);   // cuccumber, tomatoes, onion
    }

    // 값(amount)를 대상으로 순회한다.
    for(let amount of recipeMap.vlaues()) {
        alert(amount);      // 500, 350, 50
    }

    // [키, 값] 쌍을 대상으로 순회한다.
    for(let entry of recipeMap) {   // recipeMap.entries() 와 동일하다.
        alert(entry);   // cuccumber, 500 ....
    }

    맵은 값이 삽입된 순서대로 순회한다. 객체가 프로퍼티 순서를 기억하지 못하는 것과는 다른다.

    3) Object.entries : 객체를 맵으로 바꾸기 
    각 요소가 키-값 쌍인 배열이나 어터러블 객체를 초기화 용도로 맵에 전달해 새로운 맵을 만들 수 있다.

    let map = new Map([
        ['1', 'str'],
        [1, 'num1'],
        [true, 'bool1']
    ]);

    alert(map.get('1'));    // str1 

    평범한 객체를 가지고 맵을 만들고 싶다면 내장 메서드 Object.entries(obj) 를 활용해야 한다. 객체의 키-값
    쌍을 요소([key, value])로 가지고 배열을 반환한다.

    let obj = {
        name: "John",
        age: 30
    };

    let map = new Map(Object.entties(obj));

    alert(map.get('name'));     // John 

    Object.entries(obj)를 사용해 객체 obj를 배열 [["name,"John"],["age", 30]] 로 바꾸고 이 배열을 이용해 
    새로운 맵을 만들었다.

    4) Object.fromEntries : 맵을 객체로 바꾸기 
    Object.entries(obj)를 사용해 평범한 객체를 맵으로 바꾸었듯이 반대로 맵을 객체로 바꾸는 방법이 있다.
    Object.fromEntries를 사용하면 각 요소가 [키, 값] 쌍인 배열을 객체로 바꿔준다.

    let map = new Map();
    map.set('banana', 1);
    map.set('orange', 2);
    map.set('meat', 4);

    let obj = Object.fromEntries(map.entries());    // 맵을 일반 객체로 변환 

    // 맵이 객체가 되었음 
    // obj = {banana: 1, orange: 2, meat: 4}

    alert(obj.orange);      // 2

    map.entries()를 호출하면 맵의 [키, 값] 을 요소로 가지는 이터러블을 반환한다. Object.fromEntries 를 사용하기
    위해 딱 맞는 형태이다.

    5) 셋(Set)
    셋(Set)은 중복을 허용하지 않는 값을 모아놓은 특별한 컬랙션이다. 셋은 기가 없는 값이 저장된다.

    - new Set(iterable) : 셋을 만든다. 이터러블 객체를 잔달받으면(대개 배열을 전달받음) 그 안의 값을 복사해 셋에 넣어준다.
    - set.add(value) : 값을 추가하고 셋 자신을 반환한다.
    - set.delete(vlaue) : 값을 제거한다. 호출 시점에 셋 내에 값이 있어서 제거에 성공하면 true, 아니면 false를 반환한다.
    - set.has(value) : 셋 내에 값이 존재하면 true, 아니면 false를 반환한다.
    - set.clear() : 셋을 비운다.
    - set.size : 셋에 몇 개의 값이 있는지 세준다.

    셋 내에 동일한 값(value)이 있다면 set.add(vlaue)을 아무리 많이 호출하더라도 아무런 반응이 없을 것이다. 셋 내의 값에
    중복이 없는 이유가 바로 이 때문이다.

    6) 셋의 값에 반복 작업하기 
    for..of나 forEach 를 사용하면 셋의 값을 대상으로 반복 작업을 수행할 수 있다.

    - set.keys() : 셋 내의 모든 값을 포함하는 이터러블 객체를 반환한다.
    - set.vlaue() : set.keys 와 동일한 작업을 한다. 맵과 혼환성을 위해 만들어진 메서드이다.
    - set.entries() : 셋 내의 각 값을 이용해 만든 [value, value] 배열을 포함하는 이터러블 객체를 반환한다. 맵과의 호환성을 위해 만들어졌다.


33. 위크맵과 위크셋 
    자료구조를 구성하는 요소도 자신이 속한 자료구조가 메모리에 남아있는 동안 대개 도달 가능한 값으로 취급되어 메모리에서 삭제되지 않는다.
    예를 들어 배열에 객체 하나를 추가햐면 배열이 메모리에 남아있는 한 배열의 요소인 이 객체도 메모리에 남아았게 된다.

    맵에서 객체를 키로 사용한 경우 역시 맵이 메모리에 있는 한 객체도 메모리에 남는다. 가비지 컬렉터의 대상이 되지 않는다.
    이런 관점에서 위크맵과 일반 맵은 전혀 다른 양상을 보인다. 위크맵을 사용하면 키로 쓰인 객체가 가비지 컬렉션의 대상이 된다.

    1) 위크맵
    맵과 위크맵의 첫 번째 차이는 위크맵의 키가 반드시 객체여야 한다. 원시값은 위크맵의 키가 될 수 없다.
    두 번째 차이는 위크맵은 반복작업과 key(), vlaue(), entries() 메서드를 지원하지 않는다.

    - new WeakMap() : 위크맵을 만든다.
    - weakMap.get(key)
    - weakMap.set(key, value)
    - weakMap.delete(key)
    - weakMap.has(key)

    위크맵은 임시 저장소로 사용하는 경우 잘 활용된다 ??

    2) 위크셋
    위크셋은 셋과 유사한데 객체만 저장할 수 있다. 원시값은 저장할 수 없다.
    셋 안의 객체는 도달 가능할 때만 메모리에서 유지된다. 
    셋과 마찬가리조 위크셋이 지원하는 메서드는 단출하다. add, has, delete를 사용할 수 있고, size, keys()나 반복 작업 관련
    메서드는 사용할 수 없다.


34. Object.keys, vlues, entries 
    keys(), values(), entries()를 사용할 수 있는 자료 구조는 Map , Set, Array 이다.

    1) Object.keys, values, entries 
    입반 객체엔 다음과 같은 메서드를 사용할 수 있다.
    - Object.keys(obj) : 객체의 키만 담은 배열을 반환한다.
    - Object.vlaues(obj) : 객체의 값만 담은 배열을 반환한다.
    - Object.entries(obj) : [키, 값] 쌍을 담은 배열을 반환한다.

    2) 객체 변환하기
    객체엔 map, filter 같은 배열 전용 메서드를 사용할 수 없다.
    하지만 Object.entries 와 Object.fromEntries 를 순차적으로 적용하면 객체에도 배열 전용 매서드를 사용할 수 있다.
    - Object.entries(obj) 를 사용하여 객체의 키-값 쌍이 요소인 배열을 얻는다.
    - 만든 배열에 map 등의 배열 전용 메서드를 적용한다.
    - 반환된 배열에 Object.fromEntries(array) 를 적용해 배열을 다시 객체로 되돌린다.


35. 구조 분해 할당 
    객체와 배열은 자바스크립트에서 가장 많이 쓰이는 자료 구조이다.
    키를 가진 데이터 여러 개를 하나의 엔티티에 저장할 땐 객체를, 컬렉션에 데이터를 순서대로 저장할 땐 배열을 사용한다.
    개발을 하다 보면 함수에 객체나 배열을 전달해야 하거나 객체나 배열에 저장된 데이터 전체가 아닌 일부만 필요한 경우가 생긴다.
    이럴 때 객체나 배열을 변수로 분해할 수 있게 해주는 특별한 문법인 구조 분해 할당을 사용할 수 있다.

    1) 배열 분해하기

    let arr = ["Bora", "Lee"];  // 이름과 성을 요소로 가진 배열 

    // 구조 분행 할당을 이용해 firstName엔 arr[0]을 surname엔 arr[1]을 할당하였다
    let [firstName, surname] = arr;

    alert(firstName);   // Bora
    alert(surname);     // Lee 

    혹은 split 매서드를 이용하여 활용할 수 있다

    let [firstName, surname] = "Bora Lee".split(' ');

    - '...'로 나머지 요소 가져오기 
    배열 앞쪽에 위치한 값 몇 개만 필요하고 그 이후 이어지는 나머지 값들은 한데 모아서 저장하고 싶을 때는 점 세 게 ... 를 붙인 매개변수
    하나를 추가하면 나머지(rest) 요소를 가져올 수 있다.

    rest는 나머지 배열 요소들이 저장된 새로운 배열이 된다.

    - 기본값 
    할당하고자 하는 변수의 개수가 분해하고자 하는 배열의 길이보다 크더라도 에러가 발생하지 않는다. 할당할 값이 없으면 undefine 로 취급되기
    때문이다. 
    = 을 이용하면 할당할 값이 없을 때 기본으로 할댱해 줄 값인 '기본값'을 설정할 수 있다.

    2) 객체 분행하기 
    구조 분해 할당으로 객체도 분해할 수 있다.

    let {var1, var2} = {val1:..., var2:...}

    할당 연산자 우측엔 분해하고자 하는 객체를, 좌측엔 상응하는 객체 프러퍼티의 패턴을 넣는다.
    프로퍼티가 없는 경우를 대비하여 = 을 사용해 기본값을 설정하는 것도 가능하다.

    - 나머지 패턴 '...' 
    나머지 패턴을 사용하면 배열에서 했던 것처럼 나머지 프로퍼티를 어딘가에 할당하는 것도 가능하다.

    3) 중첩 구조 분해 
    객체나 배열이 다른 객체나 배열을 포함하는 경우 좀 더 복잡한 패턴을 사용하면 중접 배열이나 객체의 정보를 추출할 수 있다.
    이를 중첩 구조 분해(nested destructuring) 라고 부른다.

    let options = {
        size: {
            width: 100,
            height: 200
        },
        items: ["Cake", "Donut"],
        extra: true
    };

    // 코드를 여러 줄에 걸쳐 작성해 의도하는 바를 명확히 드러냄

    let {
        size: { // size는 여기,
            width,
            height
        },
        items: [item1, item2], // items는 여기에 할당함
        title = "Menu" // 분해하려는 객체에 title 프로퍼티가 없으므로 기본값을 사용함
    } = options;

    alert(title);  // Menu
    alert(width);  // 100
    alert(height); // 200
    alert(item1);  // Cake
    alert(item2);  // Donut

    4) 똑똑한 함수 매개변수 

    function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
        // ...
    }

    위와 같은 함수의 매개변수가 많은 경우 인수의 순서가 틀리면 문제가 발생할 수 있다.
    그리고 매개변수가 많아질수록 가독성도 떨어진다.

    매개변수 모두를 객체에 모아 함수에 전달해, 함수가 전달받은 객체를 분해하여 변수에 할당하고 원하는 작업을 수행할 수 있도록 하면 된다.

    // 함수에 전달할 객체
    let options = {
        title: "My menu",
        items: ["Item1", "Item2"]
    };

    // 똑똑한 함수는 전달받은 객체를 분해해 변수에 즉시 할당함
    function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
        // title, items – 객체 options에서 가져옴
        // width, height – 기본값
        alert( `${title} ${width} ${height}` ); // My Menu 200 100
        alert( items ); // Item1, Item2
    }

    showMenu(options);


36. Date 객체와 날짜 
    1) 객체 생성하기 

    let now = new Date();   // 인수 없이 호출하면 현재 날짜와 시간이 저장된 Date 객체가 반환된다.

    그외 인수를 사용하여 생성하는 방법은 다음과 같다.

    - new Date(milliseconds)
    - new Date(datestring)      // new Date("2017-01-26")
    - new Date(year, month, date, hours, minutes, seconds, ms) // year는 4자리, month 는 0 ~ 11 

    2) 날짜 구성요소 얻기 

    - getFullYear() : 연도(네자리수)를 반환한다.
    - getMonth() : 월을 반환한다.(0~11)
    - getDate() : 일을 반환한다.(1 ~ 31)
    - getHours(), getMinutes(), getSeconds(), getMilliseconds() : 시, 분, 초, 밀리초를 반환한다.

    - getDay() : 일요일을 0 으로 하여 토요일을 6으로 하는 값을 반환한다.
    - getTime() : 타임스탬프를 반환한다.
    - getTimezoneOffset() : 현지 시간과 표준 시간의 차이(분)를 반환한다.

    3) 날짜 구성요소 설정하기 

    - setFullYear(year, [month], [date])
    - setMonth(month, [date])
    - setDate(date)
    - setHours(hours, [min], [sec], [ms])
    - setMinutes(min, [sec], [ms])
    - setSeconds(sec, [ms])
    - setMilliseconds(ms)
    - setTime(타임스템프값)

    4) 자동 고침
    Date 객체엔 자동 고침이라는 유용한 기능이 있다. 범위를 벗어나는 값을 설정하면 자동 고침 기능이 활성화 된다.

    5) Date 객체를 숫자로 변경해 시간차 측정하기
    Date 객체를 숫자형으로 변경하면 타임스템프(date.getTime()을 호출시 반환되는 값)가 된다.

    let date = new Date();
    alert(+date);   // 타임스템스(date.getTime()을 호출한 것과 동일함)

    위 코드를 두번 사용하여 시간차를 측정한다. 

    6) Date.now() 
    Date 객체를 만들지 않고도 시차를 측정할 수 있다. 현재 타임스템프를 반환하는 메스트 Date.now()를 응용하면 된다.
    Date.now() 는 new Date().getTime()과 의미론적으로 동일하지만 중간에 Date 객체를 만들지 않는다는 점이 다르다.

    7) 벤치마크 테스트

    8) Date.parse 와 문자열 
    메서드 Date.parse(str) 을 사용하면 문자열에서 날짜를 읽어올 수 있다. 
    단 문자열의 형식은 YYYY-MM-DDTHH:mm:ss.sssZ 처럼 생겨야 한다.
    YYYY-MM-DD : 날짜(연-월-일)
    'T' : 구분 기호로 쓰임 
    HH:mm:ss.sss : 시:분:초.밀리초 
    'Z'(옵션) : +-hh:mm 형식의 시간대를 나타냄. Z 한 글자인 경우엔 UTC+0을 나타냄 

    문자열 형식이 조건에 맞지 않을 경우엔 NaN 이 반환된다.


37. JSON과 메서드
    JSON (JavaScript Object Notation)은 값이나 객체를 나타내주는 범용 포멧으로 RFC 4627 표준에 정의되어 있다.
    주로 타 언어나 자바스크립트에서 데이터 교환 목적으로 사용하는 경우가 많다.(클라이언트측 언어가 자바스크립트일 경우)

    1) JSON.stringify 
    - JSON.stringify : 객체를 JSON으로 바꿔 준다.
    - JSON.parse : JSON을 객체로 바꿔 준다.

    JSON.stringify는 객체뿐만 아니라 원시값에도 적용할 수 있다.
    - 객체 {...}
    - 배열 [...]
    - 원시형 
        . 문자형 
        . 숫자형 
        . 블린형 값 true or false 
        . null

    JSON.stringify 호출 시 무시되는 프로퍼티 
    - 함수 프로퍼티 (메서드)
    - 심볼형 프러퍼티 (키가 핌볼인 프로퍼티)
    - 값이 undefined 인 프로퍼티

    JSON.stringify 의 장점 중 하나는 중첩 객체도 알아서 문자열로 바꿔준다는 점이다.

    JSON.stringify 는 순환참조가 있으면 원하는 대로 겍체를 문자열로 바꾸는게 불가능하다.

    2) replacer로 원하는 프로퍼티만 직렬화 하기 

    let json = JSON.stringify(vlaue, [replacer, space])
    - value : 인코딩 하려는 값 
    - replacer : JSON으로 인코딩 하길 원하는 프로퍼티가 담긴 배열 혹은 매핑 함수 function(key, value)
    - space : 서식 변경 목적으로 사용할 공백 문자 수 

    대다수의 경우 JSON.stringify엔 인수를 하나만 넘겨서 사용하는데 순환 참조를 다뤄야 하는 경우같이 전환 프로세스를
    정교하게 조정하려먼 두 번째 인수를 사용해야 한다.

    let room = {
        number: 23
    };

    let meetup = {
        title: "Conference",
        participants: [{name: "John"}, {name: "Alice"}],
        place: room     // meetup 은 room을 참조한다.
    };

    room.occupiedBy = meetup;   // room referene meetup 
    alert(JSON.stringify(meetup, ['title', 'participants']));   // {"title":"Conference","participants":[{},{}]}

    배열에 넣어준 프로퍼티가 잘 출력된 것을 확인할 수 있다. 그런데 배열에 name을 넣지 않아서 출력된 문자열의 participants가 텅 비어있다.

    alert(JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']));
    /*
    {
        "title":"Conference",
        "participants":[{"name":"John"},{"name":"Alice"}],
        "place":{"number":23}
    }
    */

    위처럼 변경하면 occupiedBy를 제외한 모든 프로퍼티가 직렬화되었다.

    replacer 자리에 배열 대신 함수를 전달해 보자 

    alert( JSON.stringify(meetup, function replacer(key, value) {
        alert(`${key}: ${value}`);
        return (key == 'occupiedBy') ? undefined : value;
    }));
    /* replacer 함수에서 처리하는 키:값 쌍 목록
        :             [object Object]
        title:        Conference
        participants: [object Object],[object Object]
        0:            [object Object]
        name:         John
        1:            [object Object]
        name:         Alice
        place:        [object Object]
        number:       23
    */

    3) space로 가독성 높이기 
    JSON.stringify(value, replacer, space) 의 세 번째 인수 space 는 가독성을 높이기 위해 중간에 삽입해 줄 공백 문자 수이다.

    4) 커스텀 "toJSON"
    toString을 사용해 객체를 문자형으로 변환시키는 것처럼 객체에 toJSON 이라는 메서드가 구현되어 있으면 객체를 JSON 으로 바꿀수 있다.
    JSON.stringify 눈 이런 경우를 감지하고 toJSON을 자동으로 호출한다.

    let room = {
        number = 23
    };

    let meetup = {
        title: "Conference",
        date: new Date(Date.UTC(2017,0,1));
        room
    };

    alert(JSON.stringify(meetup));
    /*
    {
        "title":"Conference",
        "date":"2017-01-01T00:00:00.000Z",
        "room":{"number":23}
    }
    */
    Date 객체의 내장 메서드 toJSON이 호출되면서 data의 값이 문자열로 변환된 걸 확인할 수 있다.

    let room = {
        number = 23,
        toJSON() {
            return this.number;
        }
    };

    let meetup = {
        title: "Conference",
        room
    };

    alert(JSON.stringift(room));    // 23
    alert(JSON.stringift(meetup));
    /*
    {
        "title": "Conference",
        "room": 23
    }
    */

    5) JSON.parse 
    JSON.parse를 사용하면 JSON으로 인코딩된 객체를 다시 객체로 디코딩 할 수 있다.

    let value = JSON.parse(str, [reviver]);
    - str : JSON 문자열 
    - reviver : 모든 (key, value) 쌍을 대상으로 호출되는 function(kry,value) 형태의 함수로 값을 변경시킬 수 있다.

    // 문자열로 변환된 배열 
    let number = "[0, 1, 2, 3]";

    number = JSON.parse(number);

    alert(number[1]);   // 1

    JSON은 주석을 지원하지 않는다.

    6) reviver 사용하기 
    서버로 부터 문자열로 변환된 meetup 객체를 받았을 경우 전송받은 문자열은 아래와 같이 생겼다고 가정하자.
    // title: (meetup 제목), date: (meetup 일시)
    let str = '{"title": "Conference","date": "2017-11-30T12:00:00.000Z"}';

    이 문자열을 역 직렬화해서 자바스크립트 객체로 만들어 보기 위해 JSON.parse를 호출해 보면 

    let meetup = JSON.parse(str);
    alert(meetup.date.getDate());   // 에러발생 

    meetup.date의 값이 Date 객체가 아니고 문자열이라 에러가 발생한다. 문자열을 Date 로 전환해 줘야 한다는걸 JSON.parse의 두 번째
    인수 reviver를 사용해 알려줘야 한다.

    let meetup = JSON.parse(str, function(key, value) {
        if(key == 'date') return new Date(vlaue);
        return value;
    });

    이렇게 수정해 주면 에러가 발생하지 않는다.





















    